.TH "C:/Users/BJRODIER/Documents/QT_REPO/QT_VHDL_simulator/code/Ressources/SystemC/include/sysc/datatypes/fx/sc_fxdefs.h" 3 "VHDL simulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/BJRODIER/Documents/QT_REPO/QT_VHDL_simulator/code/Ressources/SystemC/include/sysc/datatypes/fx/sc_fxdefs.h
.SH SYNOPSIS
.br
.PP
\fR#include 'sysc/kernel/sc_cmnhdr\&.h'\fP
.br
\fR#include 'sysc/utils/sc_machine\&.h'\fP
.br
\fR#include 'sysc/datatypes/fx/sc_fx_ids\&.h'\fP
.br
\fR#include 'sysc/datatypes/int/sc_nbutils\&.h'\fP
.br

.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBsc_dt\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#\fBdefine\fP \fBSC_ERROR_IF_IMPL_\fP(\fBcnd\fP,  id,  msg)"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_ASSERT_\fP(\fBcnd\fP,  msg)   (\fBvoid\fP(0))"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_ERROR_IF_\fP(\fBcnd\fP,  id)       \fBSC_ERROR_IF_IMPL_\fP( \fBcnd\fP, id, 0 )"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_CHECK_WL_\fP(wl)       \fBSC_ERROR_IF_\fP( (wl) <= 0, sc_core::SC_ID_INVALID_WL_ )"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_CHECK_N_BITS_\fP(n_bits)       \fBSC_ERROR_IF_\fP( (n_bits) < 0, sc_core::SC_ID_INVALID_N_BITS_ )"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_CHECK_DIV_WL_\fP(\fBdiv_wl\fP)       \fBSC_ERROR_IF_\fP( (\fBdiv_wl\fP) <= 0, sc_core::SC_ID_INVALID_DIV_WL_ )"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_CHECK_CTE_WL_\fP(\fBcte_wl\fP)       \fBSC_ERROR_IF_\fP( (\fBcte_wl\fP) <= 0, sc_core::SC_ID_INVALID_CTE_WL_ )"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_CHECK_MAX_WL_\fP(\fBmax_wl\fP)"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_OBSERVER_\fP(\fBobject\fP,  \fBobserver_type\fP,  event)"
.br
.ti -1c
.RI "#\fBdefine\fP \fBSC_OBSERVER_DEFAULT_\fP(\fBobserver_type\fP)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBsc_dt::sc_enc\fP { \fBsc_dt::SC_TC_\fP, \fBsc_dt::SC_US_\fP }"
.br
.ti -1c
.RI "enum \fBsc_dt::sc_q_mode\fP { \fBsc_dt::SC_RND\fP, \fBsc_dt::SC_RND_ZERO\fP, \fBsc_dt::SC_RND_MIN_INF\fP, \fBsc_dt::SC_RND_INF\fP, \fBsc_dt::SC_RND_CONV\fP, \fBsc_dt::SC_TRN\fP, \fBsc_dt::SC_TRN_ZERO\fP }"
.br
.ti -1c
.RI "enum \fBsc_dt::sc_o_mode\fP { \fBsc_dt::SC_SAT\fP, \fBsc_dt::SC_SAT_ZERO\fP, \fBsc_dt::SC_SAT_SYM\fP, \fBsc_dt::SC_WRAP\fP, \fBsc_dt::SC_WRAP_SM\fP }"
.br
.ti -1c
.RI "enum \fBsc_dt::sc_switch\fP { \fBsc_dt::SC_OFF\fP, \fBsc_dt::SC_ON\fP }"
.br
.ti -1c
.RI "enum \fBsc_dt::sc_fmt\fP { \fBsc_dt::SC_F\fP, \fBsc_dt::SC_E\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSC_API\fP \fBconst\fP std::string \fBsc_dt::to_string\fP (\fBsc_enc\fP)"
.br
.ti -1c
.RI "inline::std::ostream & \fBsc_dt::operator<<\fP (::std::ostream &\fBos\fP, \fBsc_enc\fP enc)"
.br
.ti -1c
.RI "\fBSC_API\fP \fBconst\fP std::string \fBsc_dt::to_string\fP (\fBsc_q_mode\fP)"
.br
.ti -1c
.RI "inline::std::ostream & \fBsc_dt::operator<<\fP (::std::ostream &\fBos\fP, \fBsc_q_mode\fP q_mode)"
.br
.ti -1c
.RI "\fBSC_API\fP \fBconst\fP std::string \fBsc_dt::to_string\fP (\fBsc_o_mode\fP)"
.br
.ti -1c
.RI "inline::std::ostream & \fBsc_dt::operator<<\fP (::std::ostream &\fBos\fP, \fBsc_o_mode\fP o_mode)"
.br
.ti -1c
.RI "\fBSC_API\fP \fBconst\fP std::string \fBsc_dt::to_string\fP (\fBsc_switch\fP)"
.br
.ti -1c
.RI "inline::std::ostream & \fBsc_dt::operator<<\fP (::std::ostream &\fBos\fP, \fBsc_switch\fP \fBsw\fP)"
.br
.ti -1c
.RI "\fBSC_API\fP \fBconst\fP std::string \fBsc_dt::to_string\fP (\fBsc_fmt\fP)"
.br
.ti -1c
.RI "inline::std::ostream & \fBsc_dt::operator<<\fP (::std::ostream &\fBos\fP, \fBsc_fmt\fP fmt)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_BUILTIN_WL_\fP = 32"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_BUILTIN_IWL_\fP = 32"
.br
.ti -1c
.RI "\fBconst\fP \fBsc_q_mode\fP \fBsc_dt::SC_BUILTIN_Q_MODE_\fP = \fBSC_TRN\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBsc_o_mode\fP \fBsc_dt::SC_BUILTIN_O_MODE_\fP = \fBSC_WRAP\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_BUILTIN_N_BITS_\fP = 0"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_DEFAULT_WL_\fP = \fBSC_BUILTIN_WL_\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_DEFAULT_IWL_\fP = \fBSC_BUILTIN_IWL_\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBsc_q_mode\fP \fBsc_dt::SC_DEFAULT_Q_MODE_\fP = \fBSC_BUILTIN_Q_MODE_\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBsc_o_mode\fP \fBsc_dt::SC_DEFAULT_O_MODE_\fP = \fBSC_BUILTIN_O_MODE_\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_DEFAULT_N_BITS_\fP = \fBSC_BUILTIN_N_BITS_\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBsc_switch\fP \fBsc_dt::SC_BUILTIN_CAST_SWITCH_\fP = \fBSC_ON\fP"
.br
.ti -1c
.RI "\fBconst\fP \fBsc_switch\fP \fBsc_dt::SC_DEFAULT_CAST_SWITCH_\fP = \fBSC_BUILTIN_CAST_SWITCH_\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_BUILTIN_DIV_WL_\fP = 64"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_BUILTIN_CTE_WL_\fP = 64"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_BUILTIN_MAX_WL_\fP = 1024"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_DEFAULT_DIV_WL_\fP = \fBSC_BUILTIN_DIV_WL_\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_DEFAULT_CTE_WL_\fP = \fBSC_BUILTIN_CTE_WL_\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBsc_dt::SC_DEFAULT_MAX_WL_\fP = \fBSC_BUILTIN_MAX_WL_\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#\fBdefine\fP SC_ASSERT_(\fBcnd\fP, msg)   (\fBvoid\fP(0))"

.SS "#\fBdefine\fP SC_CHECK_CTE_WL_(\fBcte_wl\fP)       \fBSC_ERROR_IF_\fP( (\fBcte_wl\fP) <= 0, sc_core::SC_ID_INVALID_CTE_WL_ )"

.SS "#\fBdefine\fP SC_CHECK_DIV_WL_(\fBdiv_wl\fP)       \fBSC_ERROR_IF_\fP( (\fBdiv_wl\fP) <= 0, sc_core::SC_ID_INVALID_DIV_WL_ )"

.SS "#\fBdefine\fP SC_CHECK_MAX_WL_(\fBmax_wl\fP)"
\fBValue:\fP.PP
.nf
    SC_ERROR_IF_( (max_wl) <= 0 && (max_wl) != \-1,                            \\
        sc_core::SC_ID_INVALID_MAX_WL_ )
.fi

.SS "#\fBdefine\fP SC_CHECK_N_BITS_(n_bits)       \fBSC_ERROR_IF_\fP( (n_bits) < 0, sc_core::SC_ID_INVALID_N_BITS_ )"

.SS "#\fBdefine\fP SC_CHECK_WL_(wl)       \fBSC_ERROR_IF_\fP( (wl) <= 0, sc_core::SC_ID_INVALID_WL_ )"

.SS "#\fBdefine\fP SC_ERROR_IF_(\fBcnd\fP, id)       \fBSC_ERROR_IF_IMPL_\fP( \fBcnd\fP, id, 0 )"

.SS "#\fBdefine\fP SC_ERROR_IF_IMPL_(\fBcnd\fP, id, msg)"
\fBValue:\fP.PP
.nf
  do {                                                                        \\
    if( cnd ) {                                                               \\
        SC_REPORT_ERROR( id, msg );                                           \\
        sc_core::sc_abort(); /* can't recover from here */                    \\
    }                                                                         \\
  } while( false )
.fi

.SS "#\fBdefine\fP SC_OBSERVER_(\fBobject\fP, \fBobserver_type\fP, event)"
\fBValue:\fP.PP
.nf
{                                                                             \\
    if( (object)\&.observer() != 0 )                                            \\
    {                                                                         \\
    observer_type observer = (object)\&.lock_observer();                    \\
    observer\->event( (object) );                                          \\
    (object)\&.unlock_observer( observer );                                 \\
    }                                                                         \\
}
.fi

.SS "#\fBdefine\fP SC_OBSERVER_DEFAULT_(\fBobserver_type\fP)"
\fBValue:\fP.PP
.nf
{                                                                             \\
    if( m_observer == 0 && observer_type::default_observer != 0 )             \\
        m_observer = (*observer_type::default_observer)();                    \\
}
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for VHDL simulator from the source code\&.
